deepdive {
  
  db.default: {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://localhost:5432/deepdive_ocr"
    user: "Robin"
    password: ""
  }

  schema.variables {
    # words.is_present: Boolean
    # titles.has_extractions: Boolean

    # feature values
    features.feature_val: Boolean
    # labels
    label1.val: Boolean
    label2.val: Boolean
  }


  # TODO
  # extraction.extractors: {
  #   # We copy the initial titles to assign unique variable ids
  #   titles_extractor.output_relation: "titles"
  #   titles_extractor.input: "SELECT * from titles_initial"
  #   titles_extractor.udf: "/usr/bin/sed -e s/titles_initial.//g"
  #   # Extract the words
  #   word_extractor.output_relation: "words"
  #   word_extractor.input: "SELECT * from titles"
  #   word_extractor.udf: "examples/titles/udf/word_extractor.py"
  #   word_extractor.parallelism: 4
  #   word_extractor.dependencies: ["titles_extractor"]
  # }

  # TODO
  inference.factors: {
    # words.input_query:  "SELECT words.*, titles.* FROM words INNER JOIN titles ON words.title_id = titles.id"
    label1.input_query: "SELECT features.*, label1.* FROM features INNER JOIN label1 ON features.word_id = label1.wid WHERE features.feature_val = true"
    label1.function: "label1.val = Imply()"
    label1.weight: "?(features.feature_id)"
 
    label2.input_query: "SELECT features.*, label2.* FROM features INNER JOIN label2 ON features.word_id = label2.wid WHERE features.feature_val = true"
    # This is not correct, since 0->* is true, increasing the weight for the rule
    # label2.function: "label2.val = Imply(features.feature_val)"
    label2.function: "label2.val = Imply()"
    label2.weight: "?(features.feature_id)"
  }

  calibration.holdout_fraction: 0.25

  sampler.sampler_args: "-l 100 -s 10 -i 100 -t 1"

}